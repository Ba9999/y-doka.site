---
title: Интерфейс командной строки
name: cli
author: igsekor
summary:
  - cli
  - unix
  - терминал
  - команды
---

## Кратко

Интерфейс командной строки (терминал, консоль, Command line interface, CLI) позволяет человеку взаимодействовать с компьютером с помощью текста. Для этого пользователь отправляет в заданном формате текстовые команды, которые позволяют управлять компьютером: что и в какой последовательности делать. В ответ компьютер на экран может выводить информацию о результатах работы той или иной команды.

## Как понять

Взаимодействие с компьютером через текст появилось практически на самых первых этапах развития компьютерной техники. Такой интерфейс выглядит хоть и скучновато, но является очень мощным инструментом. В Unix-подобных системах CLI помогает пользователю настраивать операционную систему и службы в них, взаимодействовать с файлами, внешними устройствами, подключенными к компьютеру сетями, Интернетом. В Unix-подобных системах любые данные, устройство или программа в абстракции операционной системы представляется в виде файла, именно поэтому терминал в них обладает такой мощью. В других операционных системах также существуют интерфейсы командной строки, но их функционал ограничен, как правило, сервисными функциями для управления операционной системой.

Запустить терминал можно как обычную программу в вашей операционной системе. На компьютерах Mac эта программа так и называется «Терминал». В операционных системах из семейства Linux терминал установлен по умолчанию и доступен не только в списке программ, для запуска часто используется сочетание клавиш `Ctrl` + `Alt` + `t`. В Windows программа для работы с консолью самой операционной системы установлена по умолчанию, находится в меню Пуск → Все программы → Стандартные и называется «Командная строка». Однако эта командная строка не очень интересна разработчикам, которым более подойдет «[PowerShell](https://docs.microsoft.com/ru/powershell/scripting/overview?view=powershell-7.1)». А для полноценной работы лучше использовать WSL (Windows Subsystem for Linux) первой или второй версии. Эта программа является полноценной с точки зрения использования всей мощи командной строки Unix-подобных систем, ее можно [скачать из магазина приложений Microsoft Store](https://aka.ms/wslstore). Процесс установки достаточно подробно описан в [официальной документации](https://docs.microsoft.com/ru-ru/windows/wsl/install-win10).

В «Терминале» текстовый интерфейс для пользователя выглядит следующим образом:

![Структура интерфейса командной строки](assets/images/posts/js/cli/cli-command.png)

Приглашение командной строки всегда отображается, когда операционная система готова выполнить следующую команду пользователя. В приглашение командной строки можно вывести довольно много разной информации. Обычно по умолчанию в приглашение помещается имя компьютера, терминалом которого вы пользуетесь, и имя текущего пользователя. Для универсальности в примерах мы будем использовать `> `.

В современных компьютерах операционные системы являются многопоточными, поэтому можно использовать одновременно несколько терминалов, в каждом из которых могут выполняться свои команды. Если говорить в общем, то к CLI можно подключиться и с другого компьютера через сеть.

Каждая команда уникальна, иначе операционная система не сможет понять, что ей нужно делать. Команда — это всегда специальное слово, которое запускает отдельное приложение: пользовательскую программу, консольную утилиту, службу и тому подобное. Например, можно узнать текущую дату командой:

```bash
> date
```

Нажмите клавишу `Enter`, чтобы выполнить команду. Все, что идет после команды называется аргументами командной строки. Часть специальных аргументов, которые настраивают работу команды принято называть ключами (флагами, параметрами). С помощью ключей пользователь может указать в каком режиме будет работать команда, задать значения по умолчанию и прочее. Ключи, состоящие из нескольких символов, принято обозначать двумя дефисами в начале. Например, для большинства команд можно посмотреть короткую справку по использованию с помощью ключа `--help`.  Длинные ключи, которые используются часто, заменяются на короткий аналог (псеводоним, alias) из одного символа, например `-h` для той же справки. Короткие ключи, как правило, можно указывать вместе, поставив впереди дефис:

```bash
# Вывод календаря для текущего месяца с подсвеченной текущей датой
> cal

# Не подсвечивать текущую дату
> cal -h

# Не подсвечивать текущую дату и заменить числа месяца на номер дня в году
> cal -hj

# Не подсвечивать текущую дату и вывести календарь для всего текущего года
> cal -hy
```

Символ `#` в начале строки используется для однострочного комментария.

Вывести список всех терминалов, которые работают сейчас в системе с указанием пользователя, от имени которого они запущены и времени запуска, можно так:

```bash
> who
```

Для большинства стандартных команд существует подробное описание ключей и аргументов. Это описание доступно по команде `man`. Вы можете посмотреть краткую справку для этой команды так:

```bash
> man --help
man, version 1.6g

usage: man [-adfhktwW] [section] [-M path] [-P pager] [-S list]
  [-m system] [-p string] name ...

  a : find all matching entries
  c : do not use cat file
  d : print gobs of debugging information
  D : as for -d, but also display the pages
  f : same as whatis(1)
  h : print this help message
  k : same as apropos(1)
  K : search for a string in all pages
  t : use troff to format pages for printing
  w : print location of man page(s) that would be displayed
      (if no name given: print directories that would be searched)
  W : as for -w, but display filenames only

  C file   : use `file' as configuration file
  M path   : set search path for manual pages to `path'
  P pager  : use program `pager' to display pages
  S list   : colon separated section list
  m system : search for alternate system's man pages
  p string : string tells which preprocessors to run
              e - [n]eqn(1)   p - pic(1)    t - tbl(1)
              g - grap(1)     r - refer(1)  v - vgrind(1)
```

На следующей строке вы видите текущую версию программы, затем идет описание формата команды. Квадратные скобки указывают на аргумент, который можно использовать, но он не является обязательным. Без квадратных скобок указываются аргументы, которые использовать необходимо. Этого синтаксиса, как правило, придерживаются в любой справочной информации для команд текстового интерфейса. Например `name` обозначает имя команды, справку о которой мы хотим получить. Для получения справки по команде `pwd` нужно выполнить:

```bash
> man pwd
```

Терминал перейдет в специальный режим постраничного просмотра, в котором можно перемещаться клавишами `→`, `←`, `↑`, `↓`, `PgUp`, `PgDown`, `Home`, `End`. Для того, чтобы выйти из этого режима, нажмите клавишу `q`. В справке написано, что команда `pwd` используется для того, чтобы узнать, в какой директории вы сейчас находитесь (рабочая директория). Имя этой команды идет от аббревиатуры PWD — Present Working Directory. В любом случае вы работаете внутри какой-либо рабочей директории. Среди специальных директорий можно выделить:
- корневую директорию, которая доступна в `/`;
- домашнюю директорию пользователя, доступную в `/home/<имя пользователя>` или по псевдониму `~`;
- директорию `..`, которая присутствует во всех директориях и обозначает ссылку на директорию, расположенную на уровень выше;
- директория `.`, которая также присутствует во всех директориях и является ссылкой на текущую директорию.

В Unix-подобных системах скрытые директории и файлы помечаются точкой в начале.

Сочетание клавиш `Ctrl` + `a` позволяет переместиться к началу строки, `Ctrl` + `e` — к концу. Нажав `Ctrl` + `l` вы сможете очистить экран, переместив строку приглашения к верху окна. Тоже самое будет происходить, если выполнить команду `clear`. Клавиша `Tab` позволяет использовать автодополнение, например для имени директорий или файлов. Двойное нажатие позволит посмотреть все доступные варианты. Клавишами `↑`, `↓` можно двигаться по списку уже выполненных команд, что бывает очень удобно. Чтобы посмотреть полный список команд, которые были вызваны ранее, выполните:

```bash
> history
```

Количество команд, сохраняемых в истории, ограничено настройками терминала. Все настройки, как правило сосредоточены в одном файле конфигурации, расположенном в домашней директории пользователя. Подробно о настройке терминала можно почитать, например, [здесь](https://habr.com/ru/post/516004/).

Существует довольно много разных терминалов. Для Unix-подобных систем наиболее распространенными являются [bash](https://ru.wikipedia.org/wiki/Bash) и [zsh](https://ru.wikipedia.org/wiki/Zsh). Наиболее полный список терминалов можно посмотреть в [таблице](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D1%8B%D1%85_%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D1%87%D0%B5%D0%BA).

## В работе

### Файловая система

Файловая система в Unix-подобных операционных системах устроена несколько иначе, нежели в Windows. Также есть корневая директория, также есть дерево директорий (папок), но есть и особенности. Например, в Linux файлами считается абсолютно все. Например, директория — это файл со списком файлов, которые в ней расположены, а принтер или монитор представлены в виде файлов, в которые записываются новые символы.

Все эти файлы образуют дерево с корнем в директории `/`. В отличии от Windows для разделения уровней структуры дерева файлов используется именно этот символ. Любое устройство, подключенное к компьютеру, файлы, диски, флэш-накопители, сетевые директории, устройства в сети, мониторы, принтеры, сканеры можно найти в дереве.

Логические диски могут быть, но они не обозначаются отдельными буквами, как это происходит в Windows. Для доступа в тому или иному логическому диску (разделу) его сначала надо примонтировать, а затем использовать как обычную директорию. Процесс монтирования, как правило, автоматизирован. Вам редко придется использовать специальные команды `mount` и `umount` для того, чтобы примонтировать или отмонтировать какой-либо жесткий диск, флэш-накопитель или другое устройство. Монтирование — процесс помещения файловой структуры внешнего устройства в дерево директорий операционной системы. Вы можете управлять местом монтирования (директорией, в которой будет доступна файловая система подключаемого устройства). По умолчанию все подключаемые устройства, как правило, располагаются в `/media/` в директории с именем устройства в системе.

Поскольку в Unix-подобных системах всё является файлами, существует довольно богатый функционал для работы с ними в интерфейсе командной строки. Примеры работы с файлами и директориями:

```bash
# Вывод списка файлов и поддиректорий
> ls

# C указанием служебной информации
> ls -l

# C указанием служебной информации и показом скрытых директорий и файлов
> ls -al

# Создание новой директории с указанием абсолютного пути
> mkdir /tmp/new-dir

# С ключем `-p` команда создаст все несуществующие директории
> mkdir -p /tmp/new-dir/new-sub-dir

# Переход в какую либо директорию по абсолютному пути
> cd /tmp/new-dir

# Переход в поддиректорию, если она существует
> cd new-sub-dir

# Переход на уровень вверх
> cd ..

# Переход в какую либо директорию по относительному пути
> cd ../new-sub-dir/

# Переход в предыдущую рабочую директорию
> cd -

# Создание нового пустого файла
> touch /tmp/new-dir/new-sub-dir/new-file.txt

# Вывод содержимого файла на экран
> cat /tmp/new-dir/new-sub-dir/new-file.txt

# Копирование файла
> cp /tmp/new-dir/new-sub-dir/new-file.txt /tmp/new-dir/new-sub-dir/file-copy.txt

# Перемещение всех файлов с расширением `.txt` на уровень вверх
> mv /tmp/new-dir/new-sub-dir/*.txt ../

# Удаление файла
> rm /tmp/new-dir/file-copy.txt

# Рекурсивное удаление содержимого директории вместе с текущей с самой директорией
> rm -r /tmp/new-dir
```

Важно отметить, что структура директорий в Unix-подобных системах часто бывает похожей. Но это не должно вводить в заблуждение, все директории равнозначны и могут использоваться произвольно. Важно, что для системных директорий по умолчанию выставлены правильно права доступа.

Чаще всего, в директории `/home` хранятся домашние директории пользователей, в директории `/bin` — системные утилиты, директория `/etc` используется для служб, `/tmp` — для хранения временных файлов, `/var` — для пользовательских приложений.

В Unix-подобных системах существует понятие ссылки. Это специальный файл, и если вы обращаетесь к нему, то операционная система переадресует вас к целевому файлу или целевой директории. Эта переадресация не является переходом в другое место дерева директорий, это подмена содержимого файла или директории «на лету». Ссылки бывают символическими / мягкими (symbolic links) и жесткими (hard links). Символические ссылки ближе всего к ярлыкам. При удалении целевого файла ссылка остается. Жесткие ссылки существуют на более глубоком уровне файловой системы, это своеобразный синоним файла (директории). Они указывают на сам файл (директорию), а не на путь, как это реализовано для символических ссылок. При перемещении целевого файла, жесткая ссылка остается рабочей. Разница показана на рисунке:

![Типы ссылок в Unix-подобных системах](assets/images/posts/js/cli/cli-links.png)

Чтобы управлять ссылками воспользуйтесь командами:

```bash
# Создание жесткой ссылки
> ln /tmp symlink

# Создание символической ссылки
> ln -s /tmp symlink

# Вывести информацию о ссылках (для символических будет указан путь)
> ls -li
```

### Доступ и пользователи

Изначально при проектировании операционной системы Unix был заложен принцип «Что не разрешено, то запрещено». Поскольку любая сущность является файлом, этот принцип означает, что по умолчанию в Unix-подобных операционных системах доступ ко всем файлам запрещен для всех пользователей, кроме суперпользователя с именем `root`. В дальнейшем с появлением пользователей в операционной системе им предоставляют права для отдельных объектов. На таком последовательном процессе построена безопасность использования. Работа от имени суперпользователя не рекомендуется. Вместо этого можно использовать специальный режим, выполняя команды от имени суперпользователя:

```bash
> sudo <команда> <аргументы>
Password:
```

Возможность работы от имени `root` доступна не всем пользователям, а только тем, которые находятся в специальном списке. Редактировать список, а также другие параметры команды `sudo` можно с помощью редактора `vi`, выполнив команду:

```bash
> sudo visudo
```

В Unix-подобных операционных системах доступ к файлам основан на [ACL](https://ru.wikipedia.org/wiki/ACL). Доступ получает не сам пользователь, а процесс (приложение, служба). Например, чтобы прочитать содержимое файла используется программа для чтения `cat`.

У каждого процесса есть идентификатор UID (User IDentifier), который указывает на пользователя, от имени которого процесс запущен. UID — это число, которое однозначно связано с именем пользователя. Каждый пользователь входит в одну или более групп, у каждой из которых тоже есть идентификатор GID (Group IDentifier). Одному числу UID соответствует список GID.

У каждого файла есть не только идентификатор пользователя UID, который используется для указания владельца файла, но и идентификатор группы GID — для группы владельцев. Установить имя пользователя и имя группы, которые будут являться владельцами файла можно с помощью команды:

```bash
> chown user:group file.txt
```

При обращении процесса к файлу или директории, операционная система предоставляет или не предоставляет доступ к нему на основе следующей схемы:

![Схема проверки доступа к файлу или директории](assets/images/posts/js/cli/cli-access.png)

Для установки прав доступа к файлу владельца, группы владельцев или любого пользователя применяется последовательность символов `-`, `r`, `w`, `x` (от слов read, write, execute) или трех цифр от 0 до 7 (восьмеричная система отсчета). Используется команда:

```bash
> chmod 754 file.txt
```

В примере владелец имеет возможность делать с файлом все что угодно, группа владельцев — может читать файл или выполнять (такое право нужно, например, для запуска программ), для всех остальных доступна только операция чтения. Эти же права на файл можно установить и с помощью символов так:

```bash
> chmod -rwxr-xr-- file.txt
```

Последовательность символов важна: `r` может стоять только на первом месте, `w` — на втором, а `x` — на третьем. Первый символ `-` в начале строки показывает, что перед нами обычный файл. Если он будет равен `d`, то перед нами директория. Если он будет равен `l`, то — ссылка на другой файл или папку. Кстати, при вызове команды для вывода списка содержимого папки будет использоваться именно символьная запись:

```bash
> ls -l
```

Цифры переводятся в восьмеричную систему счисления из флагов, записанных в двоичной системе. Если вы будете пользоваться цифрами то легко запомнить, что положение букв в символьной записи и чисел двоичного кода связано. Например, выражение `rw-` является аналогом `110`, что в восьмеричной системе будет равно `6`. Вы можете посмотреть полный список в [таблице](https://ru.wikipedia.org/wiki/Chmod).

Таким образом, каждому файлу ставится в соответствие владелец и группа владельцев (UID и GID), а также три числа для указания прав, которые есть у владельца (UID), группы владельцев (GID) и всех остальных пользователей. Чтобы узнать имя вашего пользователя, выполните:

```bash
> whoami
```

Управлять пользователями и группами пользователей в операционных системах семейства Linux можно с помощью набора команд:

```bash
# Создавние нового <username> пользователя
> useradd <username>

# Создавние нового пользователя <username> и одноименной папки в /home
> useradd -m <username>

# Посмотреть всех пользователей
> cut -d: -f1 /etc/passwd

# Изменение пароля пользователя
> passwd

# Создание новой группы пользователей <usergroup>
> groupadd <usergroup>

# Добавление пользователя <username> в группу пользователей <usergroup>
> usermod -a -G <usergroup> <username>

# Удаление пользователя <username> из группы пользователей <usergroup>
> gpasswd -d <username> <usergroup>

# Удаление группы пользователей
> groupdel

# Посмотреть все группы, в которых состоит пользователь
> groups

# Посмотреть все группы пользователей
> cut -d: -f1 /etc/group
```

На Mac, например, управлять пользователями можно не только через графический интерфейс, но и с помощью консольной утилиты `dscl`:

```bash
# Создание пользователя <username>
> dscl . create /Users/<username>

# Изменение пароля пользователя <username>
> dscl . passwd /Users/<username> <password>

# Добавление пользователя <username> в группу пользователей <usergroup>
> dseditgroup -o edit . -a <username> -t user <usergroup>
```

### Продвинутый уровень использования CLI

Если что-то пошло не так (например поехали шрифты или временно применились не те настройки), можно произвести реинициализацию терминала без его перезагрузки:

```bash
> reset
```

Можно найти команду, которая была выполнена ранее, введя часть символов, предварительно нажав `Ctrl` + `r` (на некоторых операционных системах `Ctrl` + `Shift` + `r`). Вы сможете ввести последовательность символов и наиболее подходящая команда будет показана. Если вы нажмете `Enter`, то она выполнится, если воспользуетесь стрелками `→`, `←`, то можно будет ее отредактировать. Повторное нажатие сочетания клавиш `Ctrl` + `r` (на некоторых операционных системах `Ctrl` + `Shift` + `r`) приведет к тому, что поиск продолжится, будут представлены другие варианты, подходящие под поисковый запрос.

Использовать предыдущую команду целиком можно так:

```bash
# Пример 1: Выполняется предыдущая команда
> ls -al /etc
...

> !!
ls -al /etc
...

# Пример 2: Использование текста предыдущей команды
> mkdir -p ~/test/cli/last-cmd

> !!/double
mkdir -p ~/test/cli/last-cmd/double

# Пример 3: Использование при отказе в доступе
> touch ~/test/cli/example.txt

> sudo chmod 700 ~/test/cli/example.txt

> sudo chown root:root

> rm ~/test/cli/example.txt -y
... Access denided

> sudo !!

# Пример 4: Замена части текста в предыдущей команде
> mkdir -p ~/test/cli/change

> mv ~/test/cli/chang ~/
...doesn't exist

> ^g^ge
mv ~/test/cli/change ~/
```

Работать с аргументами предыдущей команды можно так:

```bash
# Пример 1: Использование значения последнего аргумента
> mkdir -p ~/test/cli/last-arg

> cd !$

# Пример 2: Создание директории с похожим именем
> mkdir project

> mkdir !$-1

> ls
...

# Пример 3: Подстановка всех аргументов

```

Выполнить нескольких команд подряд можно так

```bash
# Выполнение несокльких команд последовательно
> cd ~/test/cli && mkdir test1 && cd test1 && touch test.txt && ls -l
```

В терминале существует два режима работы: приоритетный (по умолчанию) и фоновый. В первом терминал ожидает завершения работы очередной команды и только после ее завершения выводит приглашение командной строки для выполнения следующей команды. Фоновый режим позволяет не дожидаться завершения работы команды. Иногда это бывает полезно, например при длительных операциях. Выполнить команду в фоновом режиме можно так:

```bash
# Разархивация большого архива в приоритетном режиме
> tar xf archive.zip

# Разархивация большого архива в фоновом режиме
> tar xf archive.zip &
[<number>] <PID>
```

`<number>` — номер фонового процесса. Число, которое соответствует `<PID>` можно использовать для мониторинга и управления. Пример:

```bash
# Вывести список фоновых процессов
> jobs

# Перевести последний запущенный фоновый процесс в приоритетный режим
> fg

# Перевести фоновый процесс под номером <number> в приоритетный режим
> fg <number>
```
